// src/services/notification.ts
import { whatsappService } from './whatsapp';
import { userService } from './userService';
import { logger } from '../utils/logger';
import { chargingStations } from '../db/schema';
import { db } from '../db/connection';
import { eq } from 'drizzle-orm';

interface NotificationSchedule {
  userWhatsapp: string;
  stationId: number;
  type: 'reservation_expiry' | 'queue_reminder' | 'maintenance_alert';
  scheduledTime: Date;
  message?: string;
}

/**
 * Calculate distance between two coordinates using Haversine formula
 */
function calculateDistance(lat1: number, lon1: number, lat2: number, lon2: number): number {
  const R = 6371; // Earth radius in kilometers
  const dLat = toRad(lat2 - lat1);
  const dLon = toRad(lon2 - lon1);
  const a =
    Math.sin(dLat / 2) * Math.sin(dLat / 2) +
    Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) *
    Math.sin(dLon / 2) * Math.sin(dLon / 2);
  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
  return Math.round(R * c * 10) / 10; // Rounded to 1 decimal
}

function toRad(degrees: number): number {
  return degrees * (Math.PI / 180);
}

class NotificationService {
  private scheduledNotifications = new Map<string, NodeJS.Timeout>();

  /**
   * Send queue joined notification with rich content
   */
  async sendQueueJoinedNotification(userWhatsapp: string, queuePosition: any): Promise<void> {
    try {
      const station = await this.getStationDetails(queuePosition.stationId);
      const message = this.formatQueueJoinedMessage(queuePosition, station);
      await whatsappService.sendTextMessage(userWhatsapp, message);

      setTimeout(async () => {
        await whatsappService.sendListMessage(
          userWhatsapp,
          '‚ö° *Queue Management Options*',
          'Choose an action for your booking:',
          [
            {
              title: 'üìä Queue Status',
              rows: [
                { id: `queue_status_${queuePosition.stationId}`, title: 'üìç My Position', description: 'Check current queue status' },
                { id: `queue_estimate_${queuePosition.stationId}`, title: '‚è±Ô∏è Time Estimate', description: 'Get updated wait time' },
                { id: `queue_analytics_${queuePosition.stationId}`, title: 'üìà Queue Analytics', description: 'View station insights' }
              ]
            },
            {
              title: 'üîß Queue Actions',
              rows: [
                { id: `queue_remind_${queuePosition.stationId}`, title: 'üîî Reminder', description: 'Get notified 10 min before' },
                { id: `queue_cancel_${queuePosition.stationId}`, title: '‚ùå Leave Queue', description: 'Cancel your booking' },
                { id: `queue_share_${queuePosition.stationId}`, title: 'üì§ Share Status', description: 'Share with someone' }
              ]
            }
          ]
        );
      }, 2000);
    } catch (error) {
      logger.error('Failed to send queue joined notification', { userWhatsapp, error });
    }
  }

  async sendReservationConfirmation(userWhatsapp: string, stationId: number, reservationMinutes: number): Promise<void> {
    try {
      const station = await this.getStationDetails(stationId);
      const expiryTime = new Date(Date.now() + reservationMinutes * 60 * 1000);

      const message = `üéâ *SLOT RESERVED!*\n\n` +
        `üìç *${station?.name || 'Charging Station'}*\n` +
        `üìç ${station?.address || 'Loading address...'}\n\n` +
        `‚è∞ *Reservation Expires:* ${expiryTime.toLocaleTimeString()}\n` +
        `‚è≥ *You have ${reservationMinutes} minutes* to arrive\n\n` +
        `üöó *Next Steps:*\n` +
        `‚Ä¢ Navigate to the station now\n` +
        `‚Ä¢ Scan QR code or tap "Start Charging"\n` +
        `‚Ä¢ Your charging slot is secured!\n\n` +
        `üí° *Pro Tip:* Enable location sharing for real-time navigation assistance`;

      await whatsappService.sendTextMessage(userWhatsapp, message);

      if (station?.latitude && station?.longitude) {
        setTimeout(async () => {
          await whatsappService.sendLocationMessage(
            userWhatsapp,
            station.latitude,
            station.longitude,
            `${station.name} - Your Reserved Slot`,
            station.address || ''
          );
        }, 1000);
      }

      setTimeout(async () => {
        await whatsappService.sendButtonMessage(
          userWhatsapp,
          `üöÄ *Ready to charge?*\n\nArrive at the station and select an option:`,
          [
            { id: `start_charging_${stationId}`, title: '‚ö° Start Charging' },
            { id: `extend_reservation_${stationId}`, title: '‚è∞ Extend Time' },
            { id: `cancel_reservation_${stationId}`, title: '‚ùå Cancel' }
          ]
        );
      }, 3000);
    } catch (error) {
      logger.error('Failed to send reservation confirmation', { userWhatsapp, stationId, error });
    }
  }

  async sendChargingStartedNotification(userWhatsapp: string, stationId: number): Promise<void> {
    try {
      const station = await this.getStationDetails(stationId);
      const user = await userService.getUserByWhatsAppId(userWhatsapp);

      const message = `‚ö° *CHARGING STARTED!*\n\n` +
        `üìç *${station?.name || 'Charging Station'}*\n` +
        `üîã *Vehicle:* ${user?.evModel || 'Your EV'}\n` +
        `üîå *Connector:* ${user?.connectorType || 'Standard'}\n\n` +
        `üéØ *Session Active*\n` +
        `‚Ä¢ Charging in progress...\n` +
        `‚Ä¢ Real-time monitoring enabled\n` +
        `‚Ä¢ Auto-notifications every 30 minutes\n\n` +
        `üí∞ *Billing:* ‚Çπ${station?.pricePerKwh || '12'}/kWh\n` +
        `‚è±Ô∏è *Started:* ${new Date().toLocaleTimeString()}\n\n` +
        `üîî You'll receive updates automatically!`;

      await whatsappService.sendTextMessage(userWhatsapp, message);

      setTimeout(async () => {
        await whatsappService.sendListMessage(
          userWhatsapp,
          'üéõÔ∏è *Charging Session Control*',
          'Manage your charging session:',
          [
            {
              title: 'üìä Session Info',
              rows: [
                { id: `session_status_${stationId}`, title: '‚ö° Current Status', description: 'View charging progress' },
                { id: `session_estimate_${stationId}`, title: '‚è±Ô∏è Time Estimate', description: 'Completion time estimate' },
                { id: `session_cost_${stationId}`, title: 'üí∞ Cost Tracker', description: 'Real-time cost calculation' }
              ]
            },
            {
              title: 'üîß Session Control',
              rows: [
                { id: `session_pause_${stationId}`, title: '‚è∏Ô∏è Pause Charging', description: 'Temporarily stop charging' },
                { id: `session_stop_${stationId}`, title: 'üõë Stop & Complete', description: 'End charging session' },
                { id: `session_extend_${stationId}`, title: '‚è∞ Extend Session', description: 'Add more time if needed' }
              ]
            }
          ]
        );
      }, 2000);
    } catch (error) {
      logger.error('Failed to send charging started notification', { userWhatsapp, stationId, error });
    }
  }

  async sendChargingCompletedNotification(userWhatsapp: string, stationId: number): Promise<void> {
    try {
      const station = await this.getStationDetails(stationId);
      const sessionSummary = await this.generateSessionSummary(userWhatsapp, stationId);

      const message = `‚úÖ *CHARGING COMPLETE!*\n\n` +
        `üìç *${station?.name || 'Charging Station'}*\n` +
        `üïê *Completed:* ${new Date().toLocaleTimeString()}\n\n` +
        `üìä *Session Summary:*\n` +
        `‚ö° Energy: ${sessionSummary.energyDelivered} kWh\n` +
        `‚è±Ô∏è Duration: ${sessionSummary.duration} minutes\n` +
        `üí∞ Total Cost: ‚Çπ${sessionSummary.totalCost}\n` +
        `üîã Battery: ${sessionSummary.batteryLevel}% charged\n\n` +
        `üéâ *Thank you for using SharaSpot!*\n` +
        `Your charging session has been saved to your history.\n\n` +
        `üì± *Rate your experience* to help us improve!`;

      await whatsappService.sendTextMessage(userWhatsapp, message);

      setTimeout(async () => {
        await whatsappService.sendButtonMessage(
          userWhatsapp,
          `üåü *How was your charging experience?*\n\nYour feedback helps us improve!`,
          [
            { id: `rate_session_5_${stationId}`, title: '‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê Excellent' },
            { id: `rate_session_4_${stationId}`, title: '‚≠ê‚≠ê‚≠ê‚≠ê Good' },
            { id: `rate_session_3_${stationId}`, title: '‚≠ê‚≠ê‚≠ê Average' }
          ]
        );
      }, 2000);

      setTimeout(async () => {
        await whatsappService.sendListMessage(
          userWhatsapp,
          'üöÄ *What\'s Next?*',
          'Continue your journey with SharaSpot:',
          [
            {
              title: 'üîç Discover More',
              rows: [
                { id: 'find_nearby_stations', title: 'üó∫Ô∏è Find Nearby', description: 'Discover other charging stations' },
                { id: 'view_session_history', title: 'üìä My History', description: 'View past charging sessions' },
                { id: 'explore_features', title: '‚ú® Explore Features', description: 'Learn about new features' }
              ]
            },
            {
              title: '‚ö° Quick Actions',
              rows: [
                { id: 'book_again_same', title: 'üîÑ Book Again Here', description: 'Reserve another session' },
                { id: 'recommend_friends', title: 'üë• Invite Friends', description: 'Share SharaSpot with others' },
                { id: 'setup_preferences', title: '‚öôÔ∏è Update Preferences', description: 'Customize your experience' }
              ]
            }
          ]
        );
      }, 4000);
    } catch (error) {
      logger.error('Failed to send charging completed notification', { userWhatsapp, stationId, error });
    }
  }

  async sendQueueLeftNotification(userWhatsapp: string, stationId: number, reason: string): Promise<void> {
    try {
      const station = await this.getStationDetails(stationId);
      let message = '';

      switch (reason) {
        case 'user_cancelled':
          message = `‚úÖ *BOOKING CANCELLED*\n\n` +
            `üìç *${station?.name || 'Charging Station'}*\n` +
            `üïê *Cancelled:* ${new Date().toLocaleTimeString()}\n\n` +
            `Your queue position has been released.\n` +
            `Other users have been automatically promoted.\n\n` +
            `üí° *Need another station?* Let's find you alternatives!`;
          break;
        case 'expired':
          message = `‚è∞ *RESERVATION EXPIRED*\n\n` +
            `üìç *${station?.name || 'Charging Station'}*\n` +
            `üïê *Expired:* ${new Date().toLocaleTimeString()}\n\n` +
            `Your 15-minute reservation window has ended.\n` +
            `The slot has been released to the next user.\n\n` +
            `üîÑ *Want to try again?* You can rejoin the queue!`;
          break;
        default:
          message = `üìù *QUEUE STATUS UPDATED*\n\n` +
            `üìç *${station?.name || 'Charging Station'}*\n` +
            `Your booking status has been updated.\n\n` +
            `üí° *Looking for alternatives?* We can help!`;
      }

      await whatsappService.sendTextMessage(userWhatsapp, message);

      setTimeout(async () => {
        await whatsappService.sendButtonMessage(
          userWhatsapp,
          'üîç *What would you like to do next?*',
          [
            { id: `rejoin_queue_${stationId}`, title: 'üîÑ Rejoin Queue' },
            { id: 'find_alternatives', title: 'üó∫Ô∏è Find Alternatives' },
            { id: 'schedule_later', title: '‚è∞ Schedule Later' }
          ]
        );
      }, 2000);
    } catch (error) {
      logger.error('Failed to send queue left notification', { userWhatsapp, stationId, reason, error });
    }
  }

  async sendQueueProgressNotification(userWhatsapp: string, stationId: number, position: number, waitTime: number): Promise<void> {
    try {
      const station = await this.getStationDetails(stationId);
      const expectedTime = new Date(Date.now() + waitTime * 60 * 1000).toLocaleTimeString();
      let emoji = 'üìà';
      let message = '';

      if (position === 1) {
        emoji = 'üéØ';
        message = `${emoji} *YOU'RE NEXT!*\n\n` +
          `üìç *${station?.name || 'Charging Station'}*\n` +
          `üèÜ *Position:* #${position} (FIRST!)\n` +
          `‚è±Ô∏è *Expected:* ${expectedTime}\n\n` +
          `üöÄ *Get ready!* Your slot will be reserved automatically.\n` +
          `Start heading to the station now!`;
      } else if (position === 2) {
        emoji = 'üî•';
        message = `${emoji} *ALMOST THERE!*\n\n` +
          `üìç *${station?.name || 'Charging Station'}*\n` +
          `üéØ *Position:* #${position}\n` +
          `‚è±Ô∏è *Estimated Wait:* ${waitTime} minutes\n` +
          `üïê *Expected:* ${expectedTime}\n\n` +
          `üéâ *You're next in line!* Stay nearby for quick notifications.`;
      } else {
        message = `${emoji} *QUEUE PROGRESS UPDATE*\n\n` +
          `üìç *${station?.name || 'Charging Station'}*\n` +
          `üìç *Your Position:* #${position}\n` +
          `‚è±Ô∏è *Updated Wait:* ${waitTime} minutes\n` +
          `üïê *Expected:* ${expectedTime}\n\n` +
          `üö∂‚Äç‚ôÇÔ∏è *Queue is moving!* ${this.getProgressTip(position, waitTime)}`;
      }

      await whatsappService.sendTextMessage(userWhatsapp, message);

      if (position <= 3) {
        setTimeout(async () => {
          await whatsappService.sendButtonMessage(
            userWhatsapp,
            position === 1 ? 'üéØ *Your turn is coming!*' : 'üìä *Manage your booking:*',
            [
              { id: `live_status_${stationId}`, title: 'üì° Live Status' },
              { id: `share_position_${stationId}`, title: 'üì§ Share Position' },
              { id: `cancel_booking_${stationId}`, title: '‚ùå Cancel' }
            ]
          );
        }, 1500);
      }
    } catch (error) {
      logger.error('Failed to send queue progress notification', { userWhatsapp, stationId, position, waitTime, error });
    }
  }

  async scheduleReservationExpiry(userWhatsapp: string, stationId: number, expiryTime: Date): Promise<void> {
    try {
      const notificationKey = `expiry_${userWhatsapp}_${stationId}`;
      const existing = this.scheduledNotifications.get(notificationKey);
      if (existing) clearTimeout(existing);

      const warningTime = new Date(expiryTime.getTime() - 5 * 60 * 1000);
      const warningDelay = warningTime.getTime() - Date.now();
      if (warningDelay > 0) {
        const warningTimeout = setTimeout(async () => {
          await this.sendReservationWarning(userWhatsapp, stationId, 5);
        }, warningDelay);
        this.scheduledNotifications.set(`warning_${notificationKey}`, warningTimeout);
      }

      const expiryDelay = expiryTime.getTime() - Date.now();
      if (expiryDelay > 0) {
        const expiryTimeout = setTimeout(async () => {
          await this.sendReservationExpired(userWhatsapp, stationId);
          this.scheduledNotifications.delete(notificationKey);
        }, expiryDelay);
        this.scheduledNotifications.set(notificationKey, expiryTimeout);
      }

      logger.info('Reservation expiry notifications scheduled', { userWhatsapp, stationId, expiryTime });
    } catch (error) {
      logger.error('Failed to schedule reservation expiry', { userWhatsapp, stationId, expiryTime, error });
    }
  }

  private async sendReservationWarning(userWhatsapp: string, stationId: number, minutesLeft: number): Promise<void> {
    try {
      const station = await this.getStationDetails(stationId);
      const message = `‚ö†Ô∏è *RESERVATION EXPIRING SOON!*\n\n` +
        `üìç *${station?.name || 'Charging Station'}*\n` +
        `‚è∞ *${minutesLeft} minutes left* to arrive\n\n` +
        `üöó *Please hurry!* Your reserved slot will be released if you don't arrive in time.\n\n` +
        `üìç *Need directions?* Tap below for navigation.`;

      await whatsappService.sendTextMessage(userWhatsapp, message);

      setTimeout(async () => {
        await whatsappService.sendButtonMessage(
          userWhatsapp,
          '‚ö° *Quick Actions:*',
          [
            { id: `get_directions_${stationId}`, title: 'üó∫Ô∏è Get Directions' },
            { id: `extend_time_${stationId}`, title: '‚è∞ Extend Time' },
            { id: `cancel_urgent_${stationId}`, title: '‚ùå Cancel Now' }
          ]
        );
      }, 1000);

      if (station?.latitude && station?.longitude) {
        setTimeout(async () => {
          await whatsappService.sendLocationMessage(
            userWhatsapp,
            station.latitude,
            station.longitude,
            `üö® ${station.name} - HURRY! ${minutesLeft} min left`,
            'Your reserved charging slot'
          );
        }, 2000);
      }
    } catch (error) {
      logger.error('Failed to send reservation warning', { userWhatsapp, stationId, minutesLeft, error });
    }
  }

  private async sendReservationExpired(userWhatsapp: string, stationId: number): Promise<void> {
    try {
      const station = await this.getStationDetails(stationId);
      const message = `üíî *RESERVATION EXPIRED*\n\n` +
        `üìç *${station?.name || 'Charging Station'}*\n` +
        `üïê *Expired:* ${new Date().toLocaleTimeString()}\n\n` +
        `‚è∞ *Time's up!* Your 15-minute reservation window has ended.\n` +
        `The charging slot has been automatically released.\n\n` +
        `üîÑ *Don't worry!* You can rejoin the queue or find alternatives.`;

      await whatsappService.sendTextMessage(userWhatsapp, message);

      setTimeout(async () => {
        await whatsappService.sendButtonMessage(
          userWhatsapp,
          'üîÑ *What would you like to do?*',
          [
            { id: `rejoin_queue_${stationId}`, title: 'üîÑ Rejoin Queue' },
            { id: 'find_nearby_alternatives', title: 'üó∫Ô∏è Find Nearby' },
            { id: 'schedule_for_later', title: '‚è∞ Schedule Later' }
          ]
        );
      }, 2000);
    } catch (error) {
      logger.error('Failed to send reservation expired notification', { userWhatsapp, stationId, error });
    }
  }

  async notifyStationOwner(stationId: number, eventType: string, data: any): Promise<void> {
    try {
      const station = await this.getStationDetails(stationId);
      const ownerWhatsapp = station?.ownerWhatsappId;
      if (!ownerWhatsapp) {
        logger.warn('No owner WhatsApp ID found for station', { stationId });
        return;
      }

      let message = '';
      switch (eventType) {
        case 'queue_joined':
          message = `üìà *New Customer*\n\n` +
            `üè¢ *${station.name}*\n` +
            `üë§ Customer joined queue\n` +
            `üìç Position: #${data.position}\n` +
            `üïê ${new Date().toLocaleTimeString()}`;
          break;
        case 'queue_left':
          message = `üìâ *Customer Left*\n\n` +
            `üè¢ *${station.name}*\n` +
            `üë§ Customer left queue\n` +
            `üìç Was position: #${data.position}\n` +
            `üìù Reason: ${data.reason}`;
          break;
        case 'slot_reserved':
          message = `üéØ *Slot Reserved*\n\n` +
            `üè¢ *${station.name}*\n` +
            `üë§ Customer reserved slot\n` +
            `‚è∞ Expires: ${data.expiryTime.toLocaleTimeString()}`;
          break;
        case 'charging_started':
          message = `‚ö° *Charging Started*\n\n` +
            `üè¢ *${station.name}*\n` +
            `üë§ Customer started charging\n` +
            `üïê ${new Date().toLocaleTimeString()}`;
          break;
        case 'charging_completed':
          message = `‚úÖ *Session Complete*\n\n` +
            `üè¢ *${station.name}*\n` +
            `üë§ Customer completed charging\n` +
            `üïê ${new Date().toLocaleTimeString()}`;
          break;
      }

      if (message) {
        await whatsappService.sendTextMessage(ownerWhatsapp, message);
        logger.info('Station owner notified', { stationId, ownerWhatsapp, eventType });
      }
    } catch (error) {
      logger.error('Failed to notify station owner', { stationId, eventType, data, error });
    }
  }

  async sendSessionStartNotification(userWhatsapp: string, session: any): Promise<void> {
    try {
      const message = `‚ö° *SESSION MONITORING ACTIVE*\n\n` +
        `üì± *Live tracking enabled for your charging session*\n\n` +
        `üîÑ *You'll receive updates every 30 minutes*\n` +
        `üìä *Real-time cost and progress tracking*\n` +
        `üîî *Auto-notification when 80% charged*\n` +
        `‚ö° *Auto-stop when target reached*\n\n` +
        `üí° *Tip:* Keep your phone nearby for important updates!`;
      await whatsappService.sendTextMessage(userWhatsapp, message);
    } catch (error) {
      logger.error('Failed to send session start notification', { userWhatsapp, session, error });
    }
  }

  async sendSessionPausedNotification(userWhatsapp: string, session: any): Promise<void> {
    try {
      const message = `‚è∏Ô∏è *CHARGING PAUSED*\n\n` +
        `üìç *${session.stationName}*\n` +
        `üïê *Paused:* ${new Date().toLocaleTimeString()}\n\n` +
        `‚è∞ *Your slot is reserved for 10 minutes*\n` +
        `üîÑ *Charging will auto-resume if not manually stopped*\n\n` +
        `üí° *Resume anytime from your session controls*`;
      await whatsappService.sendTextMessage(userWhatsapp, message);
    } catch (error) {
      logger.error('Failed to send session paused notification', { userWhatsapp, session, error });
    }
  }

  async sendSessionResumedNotification(userWhatsapp: string, session: any): Promise<void> {
    try {
      const message = `‚ñ∂Ô∏è *CHARGING RESUMED*\n\n` +
        `üìç *${session.stationName}*\n` +
        `üïê *Resumed:* ${new Date().toLocaleTimeString()}\n\n` +
        `‚ö° *Charging is now active again*\n` +
        `üìä *Live monitoring continues*\n` +
        `üîî *You'll receive progress updates*`;
      await whatsappService.sendTextMessage(userWhatsapp, message);
    } catch (error) {
      logger.error('Failed to send session resumed notification', { userWhatsapp, session, error });
    }
  }

  async sendSessionProgressNotification(userWhatsapp: string, session: any, progress: any): Promise<void> {
    try {
      const message = `üìä *CHARGING PROGRESS UPDATE*\n\n` +
        `üìç *${session.stationName}*\n` +
        `üîã *Battery:* ${progress.currentBatteryLevel}%\n` +
        `‚ö° *Power:* ${progress.chargingRate} kW\n` +
        `üí∞ *Cost so far:* ‚Çπ${progress.currentCost}\n` +
        `‚è±Ô∏è *Est. completion:* ${progress.estimatedCompletion}\n\n` +
        `${progress.statusMessage}`;
      await whatsappService.sendTextMessage(userWhatsapp, message);
    } catch (error) {
      logger.error('Failed to send session progress notification', { userWhatsapp, session, progress, error });
    }
  }

  async sendSessionCompletedNotification(userWhatsapp: string, session: any, summary: any): Promise<void> {
    try {
      const summaryText = `üîã *Charging Complete!*\n\n` +
        `‚ö° *${session.stationName || 'Station'}*\n` +
        `üìÖ Duration: ${summary.duration}\n` +
        `üîã Energy: ${summary.energyDelivered} kWh\n` +
        `üîã Final Level: ${summary.finalBatteryLevel}%\n` +
        `üí∞ Total Cost: ‚Çπ${summary.totalCost}\n` +
        `üìä Efficiency: ${summary.efficiency}%\n\n` +
        `Thank you for using our service! üöó‚ö°`;
      await whatsappService.sendTextMessage(userWhatsapp, summaryText);
      logger.info('Session completion notification sent', { userWhatsapp, sessionId: session.id });
    } catch (error) {
      logger.error('Failed to send session completion notification', { userWhatsapp, error });
    }
  }

  async sendSessionExtendedNotification(userWhatsapp: string, session: any, newTarget: number): Promise<void> {
    try {
      const message = `‚è∞ *SESSION EXTENDED*\n\n` +
        `üìç *${session.stationName}*\n` +
        `üéØ *New Target:* ${newTarget}%\n` +
        `üîã *Current:* ${session.currentBatteryLevel}%\n\n` +
        `‚ö° *Charging will continue to your new target*\n` +
        `üìä *Updated estimates will be sent*`;
      await whatsappService.sendTextMessage(userWhatsapp, message);
    } catch (error) {
      logger.error('Failed to send session extended notification', { userWhatsapp, session, newTarget, error });
    }
  }

  async sendAnomalyAlert(userWhatsapp: string, session: any, status: any): Promise<void> {
    try {
      const message = `‚ö†Ô∏è *CHARGING ANOMALY DETECTED*\n\n` +
        `üìç *${session.stationName}*\n` +
        `üìä *Issue:* Lower than expected charging rate\n` +
        `‚ö° *Current Rate:* ${status.chargingRate} kW\n` +
        `üìà *Expected:* ${session.chargingRate} kW\n\n` +
        `üîß *Station team has been notified*\n` +
        `üìû *Contact support if issues persist*`;
      await whatsappService.sendTextMessage(userWhatsapp, message);
    } catch (error) {
      logger.error('Failed to send anomaly alert', { userWhatsapp, session, status, error });
    }
  }

  async sendAvailabilityAlert(userWhatsapp: string, stationId: number, analytics: any): Promise<void> {
    try {
      const station = await this.getStationDetails(stationId);
      const message = `üö® *STATION AVAILABLE!*\n\n` +
        `üìç *${station?.name}*\n` +
        `üü¢ *Queue Length:* ${analytics.currentQueueLength} people\n` +
        `‚è±Ô∏è *Wait Time:* ${analytics.estimatedWaitTime} minutes\n\n` +
        `‚ö° *Perfect time to charge!*\n` +
        `üöÄ *Book now for quick access*`;
      await whatsappService.sendTextMessage(userWhatsapp, message);

      setTimeout(async () => {
        await whatsappService.sendButtonMessage(
          userWhatsapp,
          'üéØ *Quick Actions:*',
          [
            { id: `quick_book_${stationId}`, title: '‚ö° Book Now' },
            { id: `get_directions_${stationId}`, title: 'üó∫Ô∏è Directions' },
            { id: `dismiss_alert_${stationId}`, title: '‚ùå Dismiss' }
          ]
        );
      }, 1000);
    } catch (error) {
      logger.error('Failed to send availability alert', { userWhatsapp, stationId, analytics, error });
    }
  }

  async sendPromotionNotification(userWhatsapp: string, stationId: number, newPosition: number): Promise<void> {
    try {
      const station = await this.getStationDetails(stationId);
      const message = `üìà *QUEUE POSITION UPDATED!*\n\n` +
        `üìç *${station?.name}*\n` +
        `üéØ *New Position:* #${newPosition}\n` +
        `‚è±Ô∏è *You moved up in the queue!*\n\n` +
        (newPosition === 1
          ? 'üéâ *You\'re next!* Get ready for your slot.'
          : newPosition === 2
          ? 'üî• *Almost there!* You\'re second in line.'
          : 'üìä *Progress!* You\'re getting closer.');
      await whatsappService.sendTextMessage(userWhatsapp, message);
    } catch (error) {
      logger.error('Failed to send promotion notification', { userWhatsapp, stationId, newPosition, error });
    }
  }

  async sendSessionReminder(userWhatsapp: string, stationId: number, status: any): Promise<void> {
    try {
      const message = `üîî *CHARGING REMINDER*\n\n` +
        `üîã *Your battery is now ${status.currentBatteryLevel}%*\n` +
        `‚è±Ô∏è *Est. completion:* ${status.estimatedCompletion}\n\n` +
        `üí° *Your EV is almost ready!*\n` +
        `üöó *Plan your departure accordingly*`;
      await whatsappService.sendTextMessage(userWhatsapp, message);
    } catch (error) {
      logger.error('Failed to send session reminder', { userWhatsapp, stationId, status, error });
    }
  }

  // ‚îÄ‚îÄ‚îÄ CORE HELPER: getStationDetails ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

  /**
   * Fetch station details and optionally compute distance from user
   */
  async getStationDetails(stationId: number, userLat?: number, userLng?: number): Promise<any> {
    try {
      const station = await db
        .select({
          id: chargingStations.id,
          name: chargingStations.name,
          address: chargingStations.address,
          latitude: chargingStations.latitude,
          longitude: chargingStations.longitude,
          totalSlots: chargingStations.totalSlots,
          availableSlots: chargingStations.availableSlots,
          totalPorts: chargingStations.totalPorts,
          availablePorts: chargingStations.availablePorts,
          pricePerKwh: chargingStations.pricePerKwh,
          connectorTypes: chargingStations.connectorTypes,
          amenities: chargingStations.amenities,
          operatingHours: chargingStations.operatingHours,
          rating: chargingStations.rating,
          averageRating: chargingStations.averageRating,
          totalReviews: chargingStations.totalReviews,
          reviewCount: chargingStations.reviewCount,
          isActive: chargingStations.isActive,
          updatedAt: chargingStations.updatedAt,
          ownerWhatsappId: chargingStations.ownerWhatsappId,
        })
        .from(chargingStations)
        .where(eq(chargingStations.id, stationId))
        .limit(1);

      if (station.length === 0) {
        logger.warn('Station not found', { stationId });
        return null;
      }

      const data = station[0];

      // Compute distance if user location is provided
      let distance: number | null = null;
      if (userLat != null && userLng != null && data.latitude && data.longitude) {
        distance = calculateDistance(
          userLat,
          userLng,
          Number(data.latitude),
          Number(data.longitude)
        );
      }

      // Normalize metrics
      const total = data.totalSlots || data.totalPorts || 1;
      const available = data.availableSlots || data.availablePorts || 0;
      const utilization = total > 0 ? Math.round(((total - available) / total) * 100) : 0;

      return {
        ...data,
        distance,
        utilization,
        availability: available > 0 ? 'Available' : total > 0 ? 'Queue Available' : 'Unavailable',
        isAvailable: available > 0,
        isBusy: utilization > 80,
        priceDisplay: `‚Çπ${data.pricePerKwh || 0}/kWh`,
        distanceDisplay: distance !== null ? `${distance} km` : 'Unknown',
        ratingDisplay: data.rating || data.averageRating
          ? `${Number(data.rating || data.averageRating).toFixed(1)} ‚≠ê`
          : 'No ratings',
        slotsDisplay: `${available}/${total} available`,
        finalRating: data.rating || data.averageRating || 0,
        finalReviews: data.totalReviews || data.reviewCount || 0,
      };
    } catch (error) {
      logger.error('Failed to get station details', { stationId, error });
      return null;
    }
  }

  private formatQueueJoinedMessage(queuePosition: any, station: any): string {
    const waitTime = queuePosition.estimatedWaitMinutes;
    const expectedTime = new Date(Date.now() + waitTime * 60 * 1000).toLocaleTimeString();
    return `üéâ *BOOKING CONFIRMED!*\n\n` +
      `üìç *${station?.name || 'Charging Station'}*\n` +
      `üéØ *Your Position:* #${queuePosition.position}\n` +
      `‚è±Ô∏è *Estimated Wait:* ${waitTime} minutes\n` +
      `üïê *Expected Time:* ${expectedTime}\n\n` +
      `‚ú® *What happens next:*\n` +
      `‚Ä¢ Live position updates every 5 minutes\n` +
      `‚Ä¢ Auto-reservation when you're #1\n` +
      `‚Ä¢ Navigation assistance when ready\n` +
      `‚Ä¢ Smart notifications throughout\n\n` +
      `üéÆ *Manage your booking with options below* ‚¨áÔ∏è`;
  }

  private async generateSessionSummary(userWhatsapp: string, stationId: number): Promise<any> {
    // TODO: Replace with real session data
    return {
      energyDelivered: 25.5,
      duration: 45,
      totalCost: 306,
      batteryLevel: 85,
    };
  }

  private getProgressTip(position: number, waitTime: number): string {
    if (position <= 3) return 'Stay nearby for quick notifications!';
    if (waitTime < 30) return 'Great time to grab a coffee nearby!';
    if (waitTime < 60) return 'Perfect for a quick meal or errands!';
    return 'Consider exploring nearby attractions!';
  }

  clearUserNotifications(userWhatsapp: string): void {
    for (const [key, timeout] of this.scheduledNotifications.entries()) {
      if (key.includes(userWhatsapp)) {
        clearTimeout(timeout);
        this.scheduledNotifications.delete(key);
      }
    }
    logger.info('Cleared scheduled notifications for user', { userWhatsapp });
  }

  getNotificationStats(): any {
    return {
      scheduledNotifications: this.scheduledNotifications.size,
      activeKeys: Array.from(this.scheduledNotifications.keys()),
    };
  }
}

export const notificationService = new NotificationService();